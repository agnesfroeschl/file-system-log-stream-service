# config for auditd daemon log of editing a file on MAC
# start it using the following command: sudo bin/logstash -f auditpipe.conf --config.reload.automatic --path.data ../

input {

 http {
        host => "localhost"
        port => "5043"
      }
}

filter {
    # drop first line "<?xml version='1.0' encoding='UTF-8'?>\n<audit>"
    if [message] =~ "^<\?xml" {
        drop{}
    }

    if [message] !~ "event\=\".*(rename|fstatat|setattrlist|write|creat|trunc|openat)"  {
       drop{}
    }

	#set ID of Log Entry
	uuid {
  		target => "id"
	}

	# interpret the message payload as XML
	xml {
   		source => "message"
    	store_xml => false
    	suppress_empty => true
    	force_array => false
    	xpath =>
    	[
    		"/record/@event", "accessCall",
    		"/record/@time", "timestampLog",
       		"/record/path[1]/text()", "pathnameSource",
       		"/record/path[3]/text()", "pathnameTarget",
       		"/record/subject/@pid", "pid",
       		"/record/subject/@uid", "username",
       		"/record/host/@hostName", "hostName",
       		"/record/host/@ip", "ip"
       	]
  	}

  	mutate {
    	add_field => {"logTypeName" => "UnixAuditdFile"}
    	replace => {"username" => "%{username[0]}"}
		replace => { "accessCall" => "%{accessCall[0]}" }
		replace => { "timestampLog" => "%{timestampLog[0]}" }
		replace => { "pid" => "%{pid[0]}" }
		replace => { "pathnameSource" => "%{pathnameSource[0]}" }
		replace => { "pathnameTarget" => "%{pathnameTarget[0]}" }
		replace => { "hostName" => "%{hostName[0]}" }
		replace => { "ip" => "%{ip[0]}" }
	}

	 if [pathnameSource] =~ ".DS_Store" {
            drop{}
     }

	grok {
	    match => { "pathnameSource" => "(?<fileSource>[A-Za-z_ 0-9\-\s_]+\.[A-Za-z]{2,4})" }
	}

	grok {
    	match => { "pathnameTarget" => "(?<fileTarget>[A-Za-z_ 0-9\-\s_]+\.[A-Za-z]{2,4})" }
    }

    grok {
    	match => { "pathnameSource" => "(?<dirSource>(.*\/))" }
    }

    grok {
    	match => { "pathnameTarget" => "(?<dirTarget>(.*\/))" }
    }

    grok {
        match => { "dirTarget" => "(?<lastDirTarget>\/([^\/]+)\/$)" }
    }

    grok {
    	match => { "fileSource" => "(?<fileType>\.[0-9a-z]{1,5})" }
    }

    if "copy" in [fileSource] {
            # extract original filename of copy in same dir: file name is always "<originalName> copy.<fileending>" or "<originalName> copy <digit>.<fileending>"
        	grok {
            	match => { "fileSource" => "(?<originalFilenameTemp>[a-zA-Z_ 0-9\-\s_]*(?=((\scopy\.)|(\s\d\.))[a-zA-Z]{2,5}))" }
            }

            mutate {
                   add_field => { "originalFilename" => "%{originalFilenameTemp}%{fileType}" }
                   add_field => { "originalPathname" => "%{dirSource}%{originalFilenameTemp}%{fileType}" }
            }
        }

	date {
	   timezone => "UTC"
	   locale => "en"
       match => [ "timestampLog", "EEE MMM dd HH:mm:ss yyyy" ]
       target => "timestampLog"
    }


  	mutate {
        rename => { "message" => "logMessage" }
        remove_field => [ "tags",  "@version", "command", "@timestamp", "headers" ]
  	}
}

output {
  	websocket{}
  	file {
            path => "/Users/Agnes/Desktop/output/log.txt"
            write_behavior => "append"
        }
}
